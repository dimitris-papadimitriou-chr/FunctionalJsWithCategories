<ul class="toc no-parts">

    <li>
        <span class="section-number">1.1 </span> Categories 10
        <ul>
            <li><span class="section-number"> 1.2 </span> Essential Lambda calculus with Js 12 </li>
            <li><span class="section-number"> 1.3 </span> SKI combinators 13 </li>
            <li><span class="section-number"> 1.4 </span> Minimum Type theory 15 </li>
            <li><span class="section-number"> 1.5 </span> String Diagrams 15 </li>
        </ul>
    </li>
    <li>
        <span class="section-number">2 </span> The Pillars 18
        <ul>
            <li><span class="section-number"> 2.1 </span> Monoids 18 </li>
            <li><span class="section-number"> 2.1.1 </span> Function composition as a monoid 21 </li>
            <li><span class="section-number"> 2.1.2 </span> Composing monoids 25 </li>
            <li><span class="section-number"> 2.1.3 </span> Folding monoids 23 </li>
            <li><span class="section-number"> 2.2 </span> folding functions under composition 25 </li>
            <li><span class="section-number"> 2.2.1 </span> Monoid homomorphisms and Parallelism 27 </li>
            <li><span class="section-number"> 2.3 </span> Higher order functions 30 </li>
            <li><span class="section-number"> 2.3.1 </span> Strategy pattern 30 </li>
            <li><span class="section-number"> 2.4 </span> Currying and partial application 32 </li>
        </ul>
    </li>
    <li>
        <span class="section-number"> 3 </span> Algebraic Data Types 37
        <ul>
            <li><span class="section-number"> 3.1 </span> The product structure: 37 </li>
            <li><span class="section-number"> 3.1.1 </span> Introduction / Elimination 39 </li>
            <li><span class="section-number"> 3.2 </span> The co-product structure: 40 </li>
            <li><span class="section-number"> 3.2.1 </span> Introduction / Elimination 42 </li>
            <li><span class="section-number"> 3.3 </span> One 43 </li>
            <li><span class="section-number"> 3.4 </span> Recursive Algebraic Types 44 </li>
            <li><span class="section-number"> 3.4.1 </span> On the value of the symbolic representation 45 </li>
            <li><span class="section-number"> 3.5 </span> Extending Union Types 47 </li>
            <li><span class="section-number"> 3.5.1 </span> Adding pattern matching 47 </li>
        </ul>
    </li>
    <li>
        <span class="section-number"> 4 </span> Functors 49
        <ul>
            <li><span class="section-number"> 4.1 </span> The Identity Functor 49 </li>
            <li><span class="section-number"> 4.2 </span> Commutative Diagrams 50 </li>
            <li><span class="section-number"> 4.3 </span> The Functor Laws 51 </li>
            <li><span class="section-number"> 4.4 </span> Extending Promise as Functor 53 </li>
            <li><span class="section-number"> 4.4.1 </span> The Promise - functor laws 53 </li>
            <li><span class="section-number"> 4.5 </span> IO Functor, a Lazy Id Functor 54 </li>
            <li><span class="section-number"> 4.5.1 </span> Thunks 54 </li>
            <li><span class="section-number"> 4.5.2 </span> IO Functor 55 </li>
            <li><span class="section-number"> 4.6 </span> Reader Functor 56 </li>
            <li><span class="section-number"> 4.7 </span> Maybe Functor 58 </li>
            <li><span class="section-number"> 4.7.0 </span> Dealing with null - Null object Design pattern  58
            </li>
            <li><span class="section-number"> 4.7.1 </span> The Null Object Design pattern 58 </li>
            <li><span class="section-number"> 4.7.2 </span> The Functional equivalent - Maybe as Functor 59 </li>
            <li><span class="section-number"> 4.8 </span> Either Functor 60 </li>
            <li><span class="section-number"> 4.9 </span> Either for exception handling 61 </li>
            <li><span class="section-number"> 4.1 </span> functors from Algebraic Data types 64 </li>
            <li><span class="section-number"> 4.11 </span> Functor Composition 66 </li>
            <li><span class="section-number"> 4.12 </span> Applicative Functor 68 </li>
            <li><span class="section-number"> 4.13 </span> Reader Applicative Functor 69 </li>
            <li><span class="section-number"> 4.14 </span> Composing Applicatives 71 </li>
            <li><span class="section-number"> 4.15 </span> Decorator design pattern functional idiom with functor 72
            </li>
        </ul>
    </li>
    <li>
        <span class="section-number"> 5 </span> An Introduction to Catamorphisms 74
        <ul>
            <li><span class="section-number"> 5.1 </span> Catamorphisms 74 </li>
            <li><span class="section-number"> 5.1.1 </span> Union types cata 75 </li>
            <li><span class="section-number"> 5.1.2 </span> Recursive types cata 76 </li>
            <li><span class="section-number"> 5.2 </span> Catamorphisms through the Visitor Design pattern 77 </li>
            <li><span class="section-number"> 5.2.1 </span> Extending Union Types: Using cata 78 </li>
            <li><span class="section-number"> 5.3 </span> Folds 78 </li>
        </ul>
    </li>

    <li>
        <span class="section-number"> 6 </span> Traversable 79
        <ul>
            <li><span class="section-number"> 6.1 </span> Traversable Array with Either applicative for validation 81
            </li>
            <li><span class="section-number"> 6.2 </span> Traversable Algebraic data structures 82 </li>
            <li><span class="section-number"> 6.3 </span> Identity Traversable 83 </li>
            <li><span class="section-number"> 6.4 </span> Applicative Reader Isomorphism with the Interpreter Design
                pattern 83 </li>
            <li><span class="section-number"> 6.5 </span> Composing Traversables 86 </li>
            <li><span class="section-number"> 6.6 </span> Foldable 86 </li>
            <li><span class="section-number"> 6.6.1 </span> FoldMap 88 </li>
            <li><span class="section-number"> 6.6.2 </span> filter 88 </li>
            <li><span class="section-number"> 6.6.3 </span> Mixins 88 </li>
            <li><span class="section-number"> 6.6.4 </span> Composing Foldables 89 </li>
            <li><span class="section-number"> 6.6.5 </span> Iterators 90 </li>
        </ul>
    </li>

    <li>
        <span class="section-number">7 </span> Yoneda Lemma 92
        <ul>
            <li><span class="section-number"> 7.1 </span> Co-Yoneda Lemma 93 </li>
        </ul>
    </li>


    <li>
        <span class="section-number"> 8 </span> Natural Transformations 95
        <ul>
            <li><span class="section-number"> 8.1.1 </span> Natural Transformation Between Maybe and Either 97 </li>
        </ul>
    </li>
    <li>
        <span class="section-number"> 9 </span> Monads 99  
    <ul>
        <li><span class="section-number"> 9 </span> Monads 99 </li>
        <li><span class="section-number"> 9.1 </span> Introduction 99 </li>
        <li><span class="section-number"> 9.2 </span> The List Monad 101 </li>
        <li><span class="section-number"> 9.3 </span> The Identity Monad 101 </li>
        <li><span class="section-number"> 9.3.1 </span> Monad laws for Identity Monad 102 </li>
        <li><span class="section-number"> 9.4 </span> Monads -Kleisli Composition in Javascript 103 </li>
        <li><span class="section-number"> 9.5 </span> Monad laws following Kleisli formulation 104 </li>
        <li><span class="section-number"> 9.6 </span> Maybe Monad 105 </li>
        <li><span class="section-number"> 9.7 </span> Either Monad 108 </li>
        <li><span class="section-number"> 9.7.1 </span> Using Either Monad exception handling 108 </li>
        <li><span class="section-number"> 9.7.2 </span> Validation type 110 </li>
        <li><span class="section-number"> 9.8 </span> State Monad 110 </li>
        <li><span class="section-number"> 9.8.1 </span> Traversing with State 113 </li>
        <li><span class="section-number"> 9.9 </span> Reader Monad 115 </li>
        <li><span class="section-number"> 9.1 </span> IO monad 117 </li>
        <li><span class="section-number"> 9.11 </span> Writer Monad 118 </li>
        <li><span class="section-number"> 9.11.1 </span> Traversing with Writer 119 </li>
        <li><span class="section-number"> 9.12 </span> Deriving the Continuation Monad 119 </li>

        <li><span class="section-number"> 9.13 </span> The continuation monad 123 </li>
        <li><span class="section-number"> 9.14 </span> Extending Promises to Monads 123 </li>
        <li><span class="section-number"> 9.14.1 </span> Async Error handling with either 125 </li>
        <li><span class="section-number"> 9.14.2 </span> Implementing Bind 126 </li>
    </ul>
    </li>

    <li>
        <span class="section-number"> 10 </span> Comonads 128  
    <ul>
        <li><span class="section-number"> 10.1 </span> The Identity Comonad 128 </li>
        <li><span class="section-number"> 10.2 </span> Co-Monad laws for Identity Co-Monad 129 </li>
        <li><span class="section-number"> 10.3 </span> CoKleisli Composition 130 </li>
        <li><span class="section-number"> 10.3.1 </span> Co-Monad laws following Co-Kleisli formulation 131 </li>
        <li><span class="section-number"> 10.4 </span> Store Comonad 131 </li>
        <li><span class="section-number"> 10.5 </span> Lazy comonad ? 132 </li>
        <li><span class="section-number"> 10.6 </span> Pair Comonad 133 </li>
        <li><span class="section-number"> 10.7 </span> Tree Comonad 136 </li>
        <li><span class="section-number"> 10.8 </span> Spatial Comonad 137 </li>
        <li><span class="section-number"> 10.9 </span> Stream Comonad 140 </li>
        <li><span class="section-number"> 10.1 </span> Tree annotation 141 </li>
    </ul>
    </li>

    <li>
        <span class="section-number">11 </span> F-Algebras 144 
    <ul>
        <li><span class="section-number">
        </span></li><li><span class="section-number"> 11.1 </span> F-Algebras Homomorhisms 148 </li>
        <li><span class="section-number"> 11.2 </span> Initial Algebras 150 </li>
        <li><span class="section-number"> 12 </span> F -Coalgebra 150 </li>
        <li><span class="section-number"> 12.1 </span> Catmorphisms 151 </li>
    </ul>
    </li>

</ul>